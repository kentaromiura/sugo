{
  "name": "es6-transpiler",
  "version": "0.7.4",
  "description": "es6 -> es5",
  "main": "./build/es5/es6-transpiler.js",
  "bin": {
    "es6-transpiler": "./build/es5/es6toes5"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/termi/es6-transpiler.git"
  },
  "dependencies": {
    "simple-fmt": "~0.1.0",
    "simple-is": "~0.2.0",
    "stringmap": "~0.2.0",
    "stringset": "~0.2.0",
    "ansidiff": "~1.0.0"
  },
  "keywords": [
    "es6-transpiler",
    "scope",
    "blockscope",
    "block-scope",
    "let",
    "const",
    "var",
    "es6",
    "transpile",
    "transpiler"
  ],
  "scripts": {
    "test": "node --harmony run-tests"
  },
  "author": {
    "name": "Egor Khalimonenko",
    "email": "1+es6transpiler@h123.ru"
  },
  "license": "MIT",
  "readme": "# es6-transpiler.js\r\nes6 -> es5\r\n\r\n## status\r\n\r\nBeta\r\n\r\n## Supported\r\n\r\n * classes\r\n * destructuring\r\n * blockBinding (let / const)\r\n * defaultParameters\r\n * arrowFunctions\r\n * spread (with iterator protocol)\r\n * for-of (with iterator protocol)\r\n * array comprehensions (with iterator protocol)\r\n * templateLiterals\r\n * objectLiteral\r\n\r\nStatic scope analysis and transpilation of ES6 block scoped `const` and `let` variables to ES3 (based on https://github.com/olov/defs).\r\n\r\n## Supported iterator protocol\r\n\r\n```javascript\r\nvar obj = {a: 1, b: 2, c: 3};\r\nobj.iterator = function() {\r\n\tvar iterableObject = this;\r\n\tvar keys = [\"a\", \"b\", \"c\"];\r\n\r\n\treturn {\r\n\t\tnext: function() {\r\n\t\t\tvar currentKey = keys.shift();\r\n\r\n\t\t\treturn {\r\n\t\t\t\tvalue: currentKey ? iterableObject[currentKey] : void 0\r\n\t\t\t\t, done: !currentKey\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Installation\r\n\r\nInstall using npm\r\n\r\n\tnpm install es6-transpiler\r\n\r\n## Usage\r\n\r\n### In console\r\n\r\nRun it as `es6toes5 file.js`. The errors (if any) will go to stderr,\r\nthe transpiled source to `stdout`, so redirect it like `es6toes5 file.js > output.js`.\r\n\r\n### Node.js\r\n\r\nrequire(\"es6-transpiler\").run(\\<Options\\>)\r\n\r\nOptions is:\r\n\r\n\t{\r\n\t\tfilename: string // input file\r\n\t\tsource: string // input source if not filename\r\n\t\toutputToConsole: boolean // if true -> result would be outputted to console\r\n\t\toutputFilename: string // if specific -> result would be written to file\r\n\t}\r\nOther options below in \"Options\" section.\r\n\r\n```javascript\r\nvar es6tr = require(\"./es6-transpiler\");\r\nvar result = es6tr.run({filename: \"test.js\"});\r\nconsole.log(result.src);//result\r\n```\r\nresult object is:\r\n\r\n    {\r\n        src: string or \"\" // on success\r\n        errors: array of error messages or [] // on errors\r\n        stats: statistics object\r\n        ast: transformed ast // ast tree from esprima\r\n    }\r\n\r\n## Options\r\n\r\nExample of `options` object:\r\n\r\n    {\r\n    \t//described above:\r\n    \t//\"filename\" or \"source\": \"string\"\r\n    \t//outputToConsole: false\r\n    \t//outputFilename: true\r\n\r\n        \"environments\": [\"node\", \"browser\"],\r\n\r\n        \"globals\": {\r\n            \"my\": false,\r\n            \"hat\": true\r\n        },\r\n        \"disallowVars\": false,\r\n        \"disallowDuplicated\": true,\r\n        \"disallowUnknownReferences\": true\r\n    }\r\n\r\n`globals` lets you list your program's globals, and indicate whether they are\r\nwritable (`true`) or read-only (`false`), just like `jshint`.\r\n\r\n`environments` lets you import a set of pre-defined globals, here `node` and\r\n`browser`. These default environments are borrowed from `jshint` (see\r\n[jshint_globals/vars.js](https://github.com/olov/defs/blob/master/jshint_globals/vars.js)).\r\n\r\n`disallowVars` (defaults to `false`) can be enabled to make\r\nusage of `var` an error.\r\n\r\n`disallowDuplicated` (defaults to `true`) errors on duplicated\r\n`var` definitions in the same function scope.\r\n\r\n`disallowUnknownReferences` (defaults to `true`) errors on references to\r\nunknown global variables.\r\n\r\n## License\r\n`MIT`, see [LICENSE](LICENSE) file.\r\n\r\n\r\n## Example\r\n\r\nSee tests\r\n\r\n\r\n## Compatibility\r\n`es6-transpiler.js` strives to transpile your program as true to the ES6 block scope semantics as\r\npossible, while being as maximally non-intrusive as possible. The only textual\r\ndifferences you'll find between your original and transpiled program is that the latter\r\nuses `var` and occasional variable renames.\r\n\r\n\r\n### Loop closures limitation\r\n`es6-transpiler.js` won't transpile a closure-that-captures-a-block-scoped-variable-inside-a-loop, such\r\nas the following example:\r\n\r\n```javascript\r\nfor (let x = 0; x < 10; x++) {\r\n    let y = x;\r\n    arr.push(function() { return y; });\r\n}\r\n```\r\n\r\nWith ES6 semantics `y` is bound fresh per loop iteration, so each closure captures a separate\r\ninstance of `y`, unlike if `y` would have been a `var`. [Actually, even `x` is bound per\r\niteration, but v8 (so node) has an\r\n[open bug](https://code.google.com/p/v8/issues/detail?id=2560) for that].\r\n\r\nTo transpile this example, an IIFE or `try-catch` must be inserted, which isn't maximally\r\nnon-intrusive. `es6-transpiler.js` will detect this case and spit out an error instead, like so:\r\n\r\n    line 3: can't transform closure. y is defined outside closure, inside loop\r\n\r\nYou need to manually handle this the way we've always done pre-`ES6`,\r\nfor instance like so:\r\n\r\n```javascript\r\nfor (let x = 0; x < 10; x++) {\r\n    (function(y) {\r\n        arr.push(function() { return y; });\r\n    })(x);\r\n}\r\n```\r\n\r\nI'm interested in feedback on this based on real-world usage of `es6-transpiler.js`.\r\n\r\n\r\n### Referenced (inside closure) before declaration\r\n`es6-transpiler.js` detects the vast majority of cases where a variable is referenced prior to\r\nits declaration. The one case it cannot detect is the following:\r\n\r\n```javascript\r\nfunction printx() { console.log(x); }\r\nprintx(); // illegal\r\nlet x = 1;\r\nprintx(); // legal\r\n```\r\n\r\nThe first call to `printx` is not legal because `x` hasn't been initialized at that point\r\nof *time*, which is impossible to catch reliably with statical analysis.\r\n`v8 --harmony` will detect and error on this via run-time checking. `es6-transpiler.js` will\r\nhappily transpile this example (`let` => `var` and that's it), and the transpiled code\r\nwill print `undefined` on the first call to `printx`. This difference should be a very\r\nminor problem in practice.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/termi/es6-transpiler/issues"
  },
  "homepage": "https://github.com/termi/es6-transpiler",
  "_id": "es6-transpiler@0.7.4",
  "_from": "es6-transpiler@*"
}
