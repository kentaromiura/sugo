{
  "name": "wrapup",
  "description": "wraps up node packages for web development",
  "version": "1.0.3",
  "license": "MIT (http://mootools.net/license.txt)",
  "main": "./lib/main.js",
  "bin": {
    "wrup": "./bin/wrup.js"
  },
  "keywords": [
    "wrap",
    "wrapper",
    "wrapup",
    "wrup",
    "packager",
    "browser",
    "package manager"
  ],
  "homepage": "http://github.com/mootools/wrapup",
  "author": {
    "name": "Valerio Proietti",
    "email": "@kamicane",
    "url": "http://mad4milk.net"
  },
  "contributors": [
    {
      "name": "Arian Stolwijk",
      "email": "@arian",
      "url": "http://aryweb.nl"
    }
  ],
  "bugs": {
    "url": "https://github.com/mootools/wrapup/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mootools/wrapup.git"
  },
  "dependencies": {
    "async": "0.2",
    "chalk": "0.4",
    "commander": "2.1",
    "prime": "0.3",
    "esprima": "~1.0.4",
    "escodegen": "1.0.x",
    "esmangle": "0.0.x",
    "graphviz": "0.0.x",
    "mkdirp": "0.3",
    "require-relative": "~0.8.7"
  },
  "devDependencies": {
    "expect.js": "0.2",
    "mocha": "1.12",
    "ansidiff": "1.0",
    "through": "~2.3.4"
  },
  "optionalDependencies": {},
  "engines": {
    "node": ">=0.6"
  },
  "scripts": {
    "test": "mocha ./test/unit --recursive && node test/run"
  },
  "readme": "![wrapup](http://github.com/mootools/wrapup/raw/master/assets/wrapup.png)\n\n## WrapUp?\n\n * WrapUp compiles CommonJS 1.0 modules for the browser.\n * WrapUp does not try to have a working `require` implementation for the browser, infact the loader WrapUp uses is [incredibly simple](https://github.com/mootools/wrapup/blob/master/includes/browser-wrapper.js).\n * WrapUp ignores duplicates that may be present when using npm to install packages.\n * WrapUp supports building multiple versions of the same package.\n * WrapUp supports circular module dependencies.\n * WrapUp can watch source files for changes and rebuild automatically.\n * WrapUp can convert CommonJS modules to AMD modules.\n\n[![Build Status](https://secure.travis-ci.org/mootools/wrapup.png)](https://travis-ci.org/mootools/wrapup)\n[![Dependency Status](https://gemnasium.com/mootools/wrapup.png)](https://gemnasium.com/mootools/wrapup)\n\n[![](https://nodei.co/npm/wrapup.png)](https://npmjs.org/package/wrapup)\n\n## Installation\n\nWrapUp is installed via npm:\n\n``` bash\nnpm install wrapup -g\n```\n\nAfter that, you will have access to `wrup` in your cli.\n\n``` bash\nwrup --help\n```\n\nYou can also install locally:\n\n``` bash\nnpm install wrapup\n```\n\nAnd require WrapUp in your node javascripts:\n\n```js\nvar wrup = require(\"wrapup\")()\n```\n\n## Usage\n\nIn a nutshell, you tell WrapUp you require `something`, it calculates\ndependencies for `something` using static analysis, and compiles a single\nJavaScript file that only exposes that `something` you required. `require`\npaths inside modules are replaced with unique identifiers for brevity, and you\nwill only be able to access directly that `something` you required, never\ndependencies (unless specifically required).\n\n### require()\n\nThe main WrapUp method is `require(namespace, module)`.\n\nIt resolves a module using node's own modules and packages logic, so for\ninstance, `wrup.require(\"colors\")` would look in your `node_modules` folder for\na package named colors, then proceed to load its `main`. The namespace parameter\nis optional, but it's used to expose the module to the browser. Without a\nnamespace, the module will be required without being assigned. A bit like doing\n`var x = require(y)` vs `require(y)`.\n\n#### cli\n\n``` bash\nwrup browser --require colors colors --require someName ./path/to/otherModule --require someOtherPackage\n```\n\n#### js\n\n```js\nvar wrup = require(\"wrapup\")(/*...options...*/) // require + instantiate\n\nwrup.require(\"colors\", \"colors\")\n    .require(\"someName\", \"./path/to/otherModule\")\n    .require(\"someOtherPackage\")\n    .up(function(err, js){\n        console.log(js)\n    })\n```\n\nThe above would let you access colors and someName, while having\nsomeOtherPackage simply required without being assigned to any variable. The\nouput code assigning variables would look like this:\n\n```js\n// those are global var statements\nvar colors = require(\"colors\")\nvar someName = require(\"someName\")\nrequire(\"someOtherPackage\")\n```\n\n### watch\n\nWrapUp supports watching source files and rebuilds automatically whenever one of\nthese changes.\n\n#### cli\n\n`--watch`\n\n#### js\n\nInstead of using the `.up()` method, the `.watch()` method is used.\n\n```javascript\nvar wrup = require(\"wrapup\")() // require + instantiate\nwrup.require(\"y\", \"./moduley.js\")\n    .watch(function(err, js){\n        fs.writeFile(\"path/to/wherever\", js)\n    })\n\nwrup.on(\"change\", function(file){\n    console.log(file + \" changed.\")\n})\n```\n\nIn the above example, whenever module `y` and any module required by module `y`\nchanges, .up() is called again. The `data` event is fired whenever WrapUp\nbuilds, either be a direct .up() call or an .up() call triggered by a changed\nfile. The `change` event is fired whenever `watch` is set to true and one of\nthe source files changes.\n\n### options\n\nSet some options for the output.\n\n```js\nvar wrapup = require('wrapup')\nwrapup({\n    globalize: \"MyNamespace\",\n    compress: true\n    // more options ...\n})\n```\n\n- `globalize` define the global scope where named modules are attached to.\n  By default it uses global var statements.\n- `compress` if set to true, will compress the resulting JavaScript file using\n  esmangle. Defaults to false.\n- `output` Used to specify an output file. Defaults to stdout.\n- `inPath` (cli: `--in-path`) Enforce that all modules are in a specified path.\n  This helps security that a random file cannot require any file on the user's\n  file system.\n- `path` (cli: `--path`) When using the AMD output mode, this will trim the\n  first parts of the path, so `-r ./foo/bar/temp --path ./foo/bar` will just\n  result in a `temp.js` file in the `--output` directory.\n- `sourcemap` (cli: `--source-map`) Specify an output file where to generate\n  source map.\n- `sourcemapURL` (cli: `--source-map-url`) `//@ sourceMappingURL` value, URL to\n  the saved sourcemap file.\n- `sourcemapRoot` (cli: `--source-map-root`) The path to the original source to\n  be included in the source map.\n- `ast` the output is a JSON object of the AST, instead of JavaScript. Can be\n  used as uglifyjs input, using `uglifyjs --spidermonkey`.\n\n#### cli\n\ncli commands:\n\n```\n    browser [options]       output the combined javascript\n    ascii                   list the dependencies as a tree\n    graph [options]         create a graphviz structured dependency graph\n    amd-combined [options]  convert to AMD format and combine the modules into one file\n    amd [options]           convert the modules into the AMD format\n```\n\n**notes:**\n\n- For `amd` the output option should be a directory\n- For `graph` to generate an actual image, you need\n  [dot](http://www.graphviz.org/) output. If you've installed graphviz, you can\n  use the `--output` option, like `--output graph.png`\n\n#### js\n\n```javascript\nwrup.require(/*...*/)\n    .require(/*...*/)\n    .up()\n```\n\n### Transforms\n\nUsing transforms you can transform any text format into something that can be\nparsed by the JS parser *esprima*. For example to precompile HTML templates or\ncompile coffeescript or typescript into JavaScript. It's also possible to do\ntransformations on the AST generated by the JavaScript parser esprima. This can\nbe used on transformation tools that can work with an AST.\n\nA source code transformation is defined as follows:\n\n```js\nexports.src = function(module, callback){\n    module.src = doSrcTransformation(module.src)\n    callback(null, module)\n}\n```\n\nA transformation that can work with the esprima AST is defined as:\n\n```js\nexports.ast = function(module, callback){\n    module.ast = doAstTransformation(module.ast)\n    callback(null, module)\n}\n```\n\nFinally [browserify transforms](https://github.com/substack/node-browserify#list-of-source-transforms)\ncan be used as well.\n\nTo use transforms on the command line, use:\n\n```bash\n# some custom module\nwrup browser --transform ./myTransformModule\n# using a package\nwrup browser --transform es6ify\n```\n\nWith the JavaScript interface\n\n```js\nwrup({\n    transforms: [\n        'es6ify',\n        './myTransformModule',\n        {src: function(module, callback){\n            module.src = module.src + ';\\n alert(\"wrup!\")'\n            callback(null, module)\n        }}\n    ]\n})\n```\n\n### Using Source Maps\n\nThe options for source-maps that can be used are `--source-map` and\n`--source-map-root`.\n\nOnce the `.map` file is created, the page with the JavaScript can be opened. It\nis important that the original files are accessible through http too. For\nexample when using `--require ./test/a --source-map test.map --source-map-root\nhttp://foo.com/src` the file `http://foo.com/src/test/a.js` should be the\noriginal JavaScript module.\n\n### Using with Uglify-JS\n\nThe WrapUp output can be piped into UglifyJS if more compression options are\ndesired. For example using the `--define` option to set global definitions.\n\n``` bash\nwrup browser -r ./main.js --source-map ./main.map \\\n     | uglify -d DEV=false --compress --mangle --output ./main.min.js \\\n              --source-map main.map --in-source-map main.map\n```\n\nUsing the `--ast` option, and the UglifyJS `--spidermonkey` option, the code\ncan be piped to UglifyJS as an Abstract Syntax Tree JSON. This saves UglifyJS\nparsing the generated WrapUp JavaScript.\n\n```bash\nwrup browser -r ./main --ast | uglifyjs --spidermonkey -c -m --output compressed.js\n```\n\n### Examples\n\n#### cli\n\n``` bash\n# simple building a file\nwrup browser --require ./main.js --output built.js\n\n# compressing the file\nwrup browser --require ./main.js --output built.js --compress\n\n# watching, and use another global object, so MyNameSpace.modulename == module.exports of main.js\nwrup browser -r modulename ./main.js --globalize MyNameSpace --compress -o path/to/file.js --watch\n\n# export modules in the global scope with \"var\" statements\n# this will create a \"var moofx = ...\" statement\nwrup browser -r moofx ./moofx\n\n# building AMD\nwrup amd --require ./main.js --output ./folder-for-converted-to-amd\n\n# building AMD with the --path option\nwrup amd --require ./path/to/files/file.js --path ./path/to/files --output ./amd\n\n# create a single optimized AMD-style using define() functions\nwrup amd-combined --require ./main.js\n\n# piping the AST JSON into uglifyjs\nwrup browser --require ./main.js --ast | uglifyjs --spidermonkey -c -m\n\n# use transforms, for example to compile coffeescript\nwrup browser -r ./test.coffee --transform coffeeify\n\n# source maps\nwrup browser -r ./main.js --output test.js --source-map test.map\n\n# generating a visual dependency graph\nwrup graph -r ./main\n# this requires that graphviz is installed\nwrup graph -r ./main --output graph.png\n# or pipe it into the \"dot\" command line tool\nwrup graph -r ./main | dot -Tpng -o graph.png\n\n# show an plain text dependency tree\nwrup ascii -r ./main\n```\n\n#### JavaScript\n\ncoming soon... :)\n",
  "readmeFilename": "README.md",
  "_id": "wrapup@1.0.3",
  "dist": {
    "shasum": "5f1ac6dc856765e747c91842eacae7fb05db779f"
  },
  "_from": "wrapup@*",
  "_resolved": "https://registry.npmjs.org/wrapup/-/wrapup-1.0.3.tgz"
}
